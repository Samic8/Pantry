module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.28.5). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateItem {
  count: Int!
}

type AggregateRestock {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Item {
  id: ID!
  name: String!
  maxOnHand: Int!
  unit: String!
  restocks(where: RestockWhereInput, orderBy: RestockOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restock!]
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  name: String!
  maxOnHand: Int!
  unit: String!
  restocks: RestockCreateManyInput
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  maxOnHand_ASC
  maxOnHand_DESC
  unit_ASC
  unit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ItemPreviousValues {
  id: ID!
  name: String!
  maxOnHand: Int!
  unit: String!
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  name: String
  maxOnHand: Int
  unit: String
  restocks: RestockUpdateManyInput
}

input ItemUpdateManyMutationInput {
  name: String
  maxOnHand: Int
  unit: String
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  maxOnHand: Int
  maxOnHand_not: Int
  maxOnHand_in: [Int!]
  maxOnHand_not_in: [Int!]
  maxOnHand_lt: Int
  maxOnHand_lte: Int
  maxOnHand_gt: Int
  maxOnHand_gte: Int
  unit: String
  unit_not: String
  unit_in: [String!]
  unit_not_in: [String!]
  unit_lt: String
  unit_lte: String
  unit_gt: String
  unit_gte: String
  unit_contains: String
  unit_not_contains: String
  unit_starts_with: String
  unit_not_starts_with: String
  unit_ends_with: String
  unit_not_ends_with: String
  restocks_every: RestockWhereInput
  restocks_some: RestockWhereInput
  restocks_none: RestockWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createRestock(data: RestockCreateInput!): Restock!
  updateManyRestocks(data: RestockUpdateManyMutationInput!, where: RestockWhereInput): BatchPayload!
  deleteManyRestocks(where: RestockWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  restocks(where: RestockWhereInput, orderBy: RestockOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restock]!
  restocksConnection(where: RestockWhereInput, orderBy: RestockOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RestockConnection!
  node(id: ID!): Node
}

type Restock {
  date: DateTime!
  newOnHand: Int!
  previousRestock: Restock
  userEstimateRunOut: DateTime
  didRunOut: DateTime
  leftOverFromPrevious: Int
}

type RestockConnection {
  pageInfo: PageInfo!
  edges: [RestockEdge]!
  aggregate: AggregateRestock!
}

input RestockCreateInput {
  date: DateTime!
  newOnHand: Int!
  previousRestock: RestockCreateOneInput
  userEstimateRunOut: DateTime
  didRunOut: DateTime
  leftOverFromPrevious: Int
}

input RestockCreateManyInput {
  create: [RestockCreateInput!]
}

input RestockCreateOneInput {
  create: RestockCreateInput
}

type RestockEdge {
  node: Restock!
  cursor: String!
}

enum RestockOrderByInput {
  date_ASC
  date_DESC
  newOnHand_ASC
  newOnHand_DESC
  userEstimateRunOut_ASC
  userEstimateRunOut_DESC
  didRunOut_ASC
  didRunOut_DESC
  leftOverFromPrevious_ASC
  leftOverFromPrevious_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RestockPreviousValues {
  date: DateTime!
  newOnHand: Int!
  userEstimateRunOut: DateTime
  didRunOut: DateTime
  leftOverFromPrevious: Int
}

input RestockScalarWhereInput {
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  newOnHand: Int
  newOnHand_not: Int
  newOnHand_in: [Int!]
  newOnHand_not_in: [Int!]
  newOnHand_lt: Int
  newOnHand_lte: Int
  newOnHand_gt: Int
  newOnHand_gte: Int
  userEstimateRunOut: DateTime
  userEstimateRunOut_not: DateTime
  userEstimateRunOut_in: [DateTime!]
  userEstimateRunOut_not_in: [DateTime!]
  userEstimateRunOut_lt: DateTime
  userEstimateRunOut_lte: DateTime
  userEstimateRunOut_gt: DateTime
  userEstimateRunOut_gte: DateTime
  didRunOut: DateTime
  didRunOut_not: DateTime
  didRunOut_in: [DateTime!]
  didRunOut_not_in: [DateTime!]
  didRunOut_lt: DateTime
  didRunOut_lte: DateTime
  didRunOut_gt: DateTime
  didRunOut_gte: DateTime
  leftOverFromPrevious: Int
  leftOverFromPrevious_not: Int
  leftOverFromPrevious_in: [Int!]
  leftOverFromPrevious_not_in: [Int!]
  leftOverFromPrevious_lt: Int
  leftOverFromPrevious_lte: Int
  leftOverFromPrevious_gt: Int
  leftOverFromPrevious_gte: Int
  AND: [RestockScalarWhereInput!]
  OR: [RestockScalarWhereInput!]
  NOT: [RestockScalarWhereInput!]
}

type RestockSubscriptionPayload {
  mutation: MutationType!
  node: Restock
  updatedFields: [String!]
  previousValues: RestockPreviousValues
}

input RestockSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RestockWhereInput
  AND: [RestockSubscriptionWhereInput!]
  OR: [RestockSubscriptionWhereInput!]
  NOT: [RestockSubscriptionWhereInput!]
}

input RestockUpdateManyDataInput {
  date: DateTime
  newOnHand: Int
  userEstimateRunOut: DateTime
  didRunOut: DateTime
  leftOverFromPrevious: Int
}

input RestockUpdateManyInput {
  create: [RestockCreateInput!]
  deleteMany: [RestockScalarWhereInput!]
  updateMany: [RestockUpdateManyWithWhereNestedInput!]
}

input RestockUpdateManyMutationInput {
  date: DateTime
  newOnHand: Int
  userEstimateRunOut: DateTime
  didRunOut: DateTime
  leftOverFromPrevious: Int
}

input RestockUpdateManyWithWhereNestedInput {
  where: RestockScalarWhereInput!
  data: RestockUpdateManyDataInput!
}

input RestockWhereInput {
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  newOnHand: Int
  newOnHand_not: Int
  newOnHand_in: [Int!]
  newOnHand_not_in: [Int!]
  newOnHand_lt: Int
  newOnHand_lte: Int
  newOnHand_gt: Int
  newOnHand_gte: Int
  previousRestock: RestockWhereInput
  userEstimateRunOut: DateTime
  userEstimateRunOut_not: DateTime
  userEstimateRunOut_in: [DateTime!]
  userEstimateRunOut_not_in: [DateTime!]
  userEstimateRunOut_lt: DateTime
  userEstimateRunOut_lte: DateTime
  userEstimateRunOut_gt: DateTime
  userEstimateRunOut_gte: DateTime
  didRunOut: DateTime
  didRunOut_not: DateTime
  didRunOut_in: [DateTime!]
  didRunOut_not_in: [DateTime!]
  didRunOut_lt: DateTime
  didRunOut_lte: DateTime
  didRunOut_gt: DateTime
  didRunOut_gte: DateTime
  leftOverFromPrevious: Int
  leftOverFromPrevious_not: Int
  leftOverFromPrevious_in: [Int!]
  leftOverFromPrevious_not_in: [Int!]
  leftOverFromPrevious_lt: Int
  leftOverFromPrevious_lte: Int
  leftOverFromPrevious_gt: Int
  leftOverFromPrevious_gte: Int
  AND: [RestockWhereInput!]
  OR: [RestockWhereInput!]
  NOT: [RestockWhereInput!]
}

type Subscription {
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  restock(where: RestockSubscriptionWhereInput): RestockSubscriptionPayload
}
`
      }
    